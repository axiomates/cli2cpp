using System.Text;
using CIL2CPP.Core.IL;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

public partial class CppCodeGenerator
{
    private GeneratedFile GenerateSource()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        if (_config.IsDebug)
        {
            sb.AppendLine("// DEBUG BUILD - contains #line directives and IL offset comments");
        }
        sb.AppendLine();
        sb.AppendLine($"#include \"{_module.Name}.h\"");
        sb.AppendLine();
        sb.AppendLine("#include <cstdio>");
        sb.AppendLine("#include <cmath>");
        sb.AppendLine("#include <cstring>");
        sb.AppendLine("#include <algorithm>");
        sb.AppendLine("#include <limits>");
        sb.AppendLine("#include <atomic>");
        sb.AppendLine();

        // String literals
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// ===== String Literals =====");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                // Escape string for C++
                var escaped = EscapeString(value);
                sb.AppendLine($"static cil2cpp::String* {literal.Id} = nullptr;");
            }
            sb.AppendLine();

            sb.AppendLine("void __init_string_literals() {");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                var escaped = EscapeString(value);
                sb.AppendLine($"    {literal.Id} = cil2cpp::string_literal(\"{escaped}\");");
            }
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Array initializer data blobs
        if (_module.ArrayInitDataBlobs.Count > 0)
        {
            sb.AppendLine("// ===== Array Initializer Data =====");
            foreach (var blob in _module.ArrayInitDataBlobs)
            {
                var bytes = string.Join(", ", blob.Data.Select(b => $"0x{b:X2}"));
                sb.AppendLine($"static const unsigned char {blob.Id}[] = {{ {bytes} }};");
            }
            sb.AppendLine();
        }

        // Filter out compiler-generated types, open generic types, and deduplicate by CppName
        var seenTypeNames = new HashSet<string>();
        var userTypes = _module.Types
            .Where(t => !CppNameMapper.IsCompilerGeneratedType(t.ILFullName))
            .Where(t => !HasUnresolvedGenericParams(t))
            .Where(t => seenTypeNames.Add(t.CppName)) // Deduplicate by CppName
            .ToList();

        // Static field storage (skip runtime-provided types)
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate || type.IsRuntimeProvided) continue;
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"{type.CppName}_Statics {type.CppName}_statics = {{}};");
            }
        }
        if (userTypes.Any(t => !t.IsEnum && !t.IsDelegate && !t.IsRuntimeProvided && t.StaticFields.Count > 0))
        {
            sb.AppendLine();
        }

        // Primitive type TypeInfo definitions (for array element types)
        // Runtime-provided reference types get aliases to runtime TypeInfo instead of new definitions.
        if (_module.PrimitiveTypeInfos.Count > 0)
        {
            sb.AppendLine("// ===== Primitive Type Info (array element types) =====");
            foreach (var entry in _module.PrimitiveTypeInfos.Values)
            {
                // Runtime-provided reference types: alias to runtime's TypeInfo (e.g., cil2cpp::System::Object_TypeInfo)
                var runtimeAlias = GetRuntimeTypeInfoAlias(entry.ILFullName);
                if (runtimeAlias != null)
                {
                    sb.AppendLine($"cil2cpp::TypeInfo& {entry.CppMangledName}_TypeInfo = {runtimeAlias};");
                    continue;
                }

                sb.AppendLine($"cil2cpp::TypeInfo {entry.CppMangledName}_TypeInfo = {{");
                sb.AppendLine($"    .name = \"{entry.ILFullName.Split('.').Last()}\",");
                sb.AppendLine($"    .namespace_name = \"{entry.ILFullName[..entry.ILFullName.LastIndexOf('.')]}\",");
                sb.AppendLine($"    .full_name = \"{entry.ILFullName}\",");
                sb.AppendLine($"    .base_type = nullptr,");
                sb.AppendLine($"    .interfaces = nullptr,");
                sb.AppendLine($"    .interface_count = 0,");
                sb.AppendLine($"    .instance_size = sizeof({entry.CppTypeName}),");
                sb.AppendLine($"    .element_size = sizeof({entry.CppTypeName}),");
                // Primitive types get both ValueType and Primitive flags (ECMA-335)
                sb.AppendLine($"    .flags = cil2cpp::TypeFlags::ValueType | cil2cpp::TypeFlags::Primitive,");
                sb.AppendLine($"    .vtable = nullptr,");
                sb.AppendLine($"    .fields = nullptr,");
                sb.AppendLine($"    .field_count = 0,");
                sb.AppendLine($"    .methods = nullptr,");
                sb.AppendLine($"    .method_count = 0,");
                sb.AppendLine($"    .default_ctor = nullptr,");
                sb.AppendLine($"    .finalizer = nullptr,");
                sb.AppendLine($"    .interface_vtables = nullptr,");
                sb.AppendLine($"    .interface_vtable_count = 0,");
                sb.AppendLine($"    .custom_attributes = nullptr,");
                sb.AppendLine($"    .custom_attribute_count = 0,");
                sb.AppendLine($"}};");
            }
            sb.AppendLine();
        }

        // Exception TypeInfo reference aliases — define references to runtime-declared TypeInfos
        // so that generated catch/cast code can use mangled names (System_Exception_TypeInfo)
        sb.AppendLine("// ===== Exception TypeInfo Aliases =====");
        foreach (var (mangledName, runtimeTypeInfoName) in GetExceptionTypeInfoAliases())
        {
            sb.AppendLine($"cil2cpp::TypeInfo& {mangledName}_TypeInfo = {runtimeTypeInfoName};");
        }
        sb.AppendLine();

        // Ensure System_Object_TypeInfo and System_String_TypeInfo exist at global scope
        // (In multi-assembly mode they're defined by PrimitiveTypeInfos; in single-assembly mode we alias)
        var needsObjectAlias = !_module.PrimitiveTypeInfos.Values.Any(e => e.ILFullName == "System.Object");
        var needsStringAlias = !_module.PrimitiveTypeInfos.Values.Any(e => e.ILFullName == "System.String");
        if (needsObjectAlias || needsStringAlias)
        {
            sb.AppendLine("// ===== Runtime TypeInfo Aliases =====");
            if (needsObjectAlias)
                sb.AppendLine("static cil2cpp::TypeInfo& System_Object_TypeInfo = cil2cpp::System_Object_TypeInfo;");
            if (needsStringAlias)
                sb.AppendLine("static cil2cpp::TypeInfo& System_String_TypeInfo = cil2cpp::System_String_TypeInfo;");
            sb.AppendLine();
        }

        // Stub TypeInfos for runtime-provided base types not declared in the runtime library
        // These are referenced as .base_type in TypeInfo initialization for value types, enums, delegates
        sb.AppendLine("// ===== Runtime Base Type TypeInfo Stubs =====");
        foreach (var (mangledName, ilName) in GetRuntimeBaseTypeInfoStubs())
        {
            sb.AppendLine($"static cil2cpp::TypeInfo {mangledName}_TypeInfo = {{ " +
                $".name = \"{ilName.Split('.').Last()}\", " +
                $".namespace_name = \"{string.Join(".", ilName.Split('.').SkipLast(1))}\", " +
                $".full_name = \"{ilName}\", " +
                $".base_type = &System_Object_TypeInfo }};");
        }
        sb.AppendLine();

        // VTable data
        EmitVTableData(sb, userTypes);

        // Interface data
        EmitInterfaceData(sb, userTypes);

        // Finalizer wrappers
        EmitFinalizerWrappers(sb, userTypes);

        // Reflection metadata (FieldInfo/MethodInfo arrays)
        EmitReflectionMetadata(sb, userTypes);

        // Generic variance data arrays (for variance-aware type checking)
        EmitGenericVarianceData(sb, userTypes);

        // Type info definitions (skip runtime-provided types — already defined in runtime)
        sb.AppendLine("// ===== Type Info =====");
        var emittedTypeInfo = new HashSet<string>();
        // Collect types that already have TypeInfo definitions (primitives, exceptions, base type stubs)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
            emittedTypeInfo.Add(entry.CppMangledName);
        foreach (var (mangledName, _) in GetExceptionTypeInfoAliases())
            emittedTypeInfo.Add(mangledName);
        foreach (var (mangledName, _) in GetRuntimeBaseTypeInfoStubs())
            emittedTypeInfo.Add(mangledName);
        foreach (var type in userTypes)
        {
            if (emittedTypeInfo.Contains(type.CppName)) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            if (!emittedTypeInfo.Add(type.CppName)) continue;
            if (type.IsRuntimeProvided)
            {
                // Emit minimal TypeInfo stub for runtime-provided types
                // (other types may reference these as base_type)
                var baseName = type.BaseType != null && emittedTypeInfo.Contains(type.BaseType.CppName)
                    ? $"&{type.BaseType.CppName}_TypeInfo" : "&System_Object_TypeInfo";
                sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{ .name = \"{type.Name}\", " +
                    $".namespace_name = \"{type.Namespace}\", .full_name = \"{type.ILFullName}\", " +
                    $".base_type = {baseName} }};");
                continue;
            }
            GenerateTypeInfo(sb, type);
        }
        sb.AppendLine();

        // Static constructor guards (skip runtime-provided types)
        foreach (var type in userTypes)
        {
            if (type.IsRuntimeProvided) continue;
            if (type.HasCctor)
            {
                var cctorMethod = type.Methods.FirstOrDefault(m => m.IsStaticConstructor);
                if (cctorMethod != null)
                {
                    sb.AppendLine($"static bool {type.CppName}_cctor_called = false;");
                    sb.AppendLine($"void {type.CppName}_ensure_cctor() {{");
                    sb.AppendLine($"    if (!{type.CppName}_cctor_called) {{");
                    sb.AppendLine($"        {type.CppName}_cctor_called = true;");
                    sb.AppendLine($"        {cctorMethod.CppName}();");
                    sb.AppendLine($"    }}");
                    sb.AppendLine($"}}");
                    sb.AppendLine();
                }
            }
        }

        // P/Invoke extern declarations and wrappers
        EmitPInvokeDeclarations(sb, userTypes);

        // Build known type set (includes all defined types, aliases, enums, forward-declared)
        var knownTypeNames = new HashSet<string>();
        foreach (var t in userTypes)
            knownTypeNames.Add(t.CppName);
        foreach (var ilName in IRBuilder.RuntimeProvidedTypes)
            knownTypeNames.Add(CppNameMapper.MangleTypeName(ilName));
        foreach (var (mangled, _) in GetRuntimeProvidedTypeAliases())
            knownTypeNames.Add(mangled);

        // Method implementations (skip runtime-provided types and InternalCall methods)
        sb.AppendLine("// ===== Method Implementations =====");
        var emittedMethodSignatures = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.IsDelegate || type.IsRuntimeProvided) continue;

            // For interfaces, only emit DIM method bodies (non-abstract with converted bodies)
            if (type.IsInterface)
            {
                var isBclInterface = type.SourceKind == AssemblyKind.BCL;
                foreach (var method in type.Methods)
                {
                    if (method.IsAbstract || method.BasicBlocks.Count == 0) continue;
                    if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                    if (!emittedMethodSignatures.Add(method.GetCppSignature())) continue;
                    if (isBclInterface)
                        GenerateMethodStub(sb, method);
                    else
                        GenerateMethodImpl(sb, method);
                }
                continue;
            }

            // BCL types: emit stub method bodies unless they compile from IL
            // Nullable/Index/Range compile from IL in MA mode; other BCL types are stubbed
            if (type.SourceKind == AssemblyKind.BCL && !IsCompileFromILType(type))
            {
                foreach (var method in type.Methods)
                {
                    if (method.IsAbstract || method.IsInternalCall || method.IsPInvoke) continue;
                    if (method.BasicBlocks.Count == 0) continue;
                    if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                    if (!emittedMethodSignatures.Add(method.GetCppSignature())) continue;
                    GenerateMethodStub(sb, method);
                }
                continue;
            }

            foreach (var method in type.Methods)
            {
                if (method.IsAbstract || method.IsInternalCall || method.IsPInvoke) continue;
                if (method.BasicBlocks.Count == 0) continue;
                if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                if (!emittedMethodSignatures.Add(method.GetCppSignature())) continue;
                GenerateMethodImpl(sb, method);
            }
        }

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.cpp",
            Content = sb.ToString()
        };
    }

    private void GenerateTypeInfo(StringBuilder sb, IRType type)
    {
        // For enum/delegate types skipped by EmitReflectionMetadata, emit type-level custom attrs
        if ((type.IsEnum || type.IsDelegate) && type.CustomAttributes.Count > 0)
        {
            EmitAttributeInfoArray(sb, $"{type.CppName}_custom_attrs", type.CustomAttributes);
        }

        var baseName = type.BaseType != null ? $"&{type.BaseType.CppName}_TypeInfo" : "nullptr";

        // Interfaces array (EmitInterfaceData skips interfaces themselves, so null for them)
        var interfacesExpr = (!type.IsInterface && type.Interfaces.Count > 0) ? $"{type.CppName}_interfaces" : "nullptr";
        var interfaceCount = type.IsInterface ? 0 : type.Interfaces.Count;

        // VTable (delegates have no vtable)
        var vtableExpr = (!type.IsInterface && !type.IsDelegate && type.VTable.Count > 0) ? $"&{type.CppName}_VTable" : "nullptr";

        // Interface vtables (also skipped for interfaces)
        var ifaceVtablesExpr = (!type.IsInterface && type.InterfaceImpls.Count > 0) ? $"{type.CppName}_interface_vtables" : "nullptr";
        var ifaceVtableCount = type.IsInterface ? 0 : type.InterfaceImpls.Count;

        // Finalizer
        var finalizerExpr = (type.Finalizer != null && !type.IsRuntimeProvided) ? $"{type.CppName}_finalizer_wrapper" : "nullptr";

        // Instance size (interfaces have no struct)
        var instanceSize = type.IsInterface ? "0" : $"sizeof({type.CppName})";

        // Flags
        var flagParts = new List<string>();
        if (type.IsValueType) flagParts.Add("cil2cpp::TypeFlags::ValueType");
        if (type.IsInterface) flagParts.Add("cil2cpp::TypeFlags::Interface");
        if (type.IsAbstract) flagParts.Add("cil2cpp::TypeFlags::Abstract");
        if (type.IsSealed) flagParts.Add("cil2cpp::TypeFlags::Sealed");
        if (type.IsEnum) flagParts.Add("cil2cpp::TypeFlags::Enum");
        var flagsStr = flagParts.Count > 0 ? string.Join(" | ", flagParts) : "cil2cpp::TypeFlags::None";

        sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{");
        sb.AppendLine($"    .name = \"{type.Name}\",");
        sb.AppendLine($"    .namespace_name = \"{type.Namespace}\",");
        sb.AppendLine($"    .full_name = \"{type.ILFullName}\",");
        sb.AppendLine($"    .base_type = {baseName},");
        sb.AppendLine($"    .interfaces = {interfacesExpr},");
        sb.AppendLine($"    .interface_count = {interfaceCount},");
        sb.AppendLine($"    .instance_size = {instanceSize},");
        sb.AppendLine($"    .element_size = 0,");
        sb.AppendLine($"    .flags = {flagsStr},");
        sb.AppendLine($"    .vtable = {vtableExpr},");
        // Reflection metadata: FieldInfo/MethodInfo arrays
        // Enums and delegates skip EmitReflectionMetadata, so always use nullptr for them
        var allFields = type.Fields.Concat(type.StaticFields).ToList();
        var reflectableMethods = type.Methods.Where(m => !CppNameMapper.IsCompilerGeneratedType(m.Name)).ToList();
        var skipReflection = type.IsEnum || type.IsDelegate || type.IsRuntimeProvided
            || CppNameMapper.IsRuntimeExceptionType(type.ILFullName);
        var fieldsExpr = (!skipReflection && allFields.Count > 0) ? $"{type.CppName}_fields" : "nullptr";
        var methodsExpr = (!skipReflection && reflectableMethods.Count > 0) ? $"{type.CppName}_methods" : "nullptr";
        if (skipReflection) { allFields = new(); reflectableMethods = new(); }
        sb.AppendLine($"    .fields = {fieldsExpr},");
        sb.AppendLine($"    .field_count = {allFields.Count},");
        sb.AppendLine($"    .methods = {methodsExpr},");
        sb.AppendLine($"    .method_count = {reflectableMethods.Count},");
        sb.AppendLine($"    .default_ctor = nullptr,");
        sb.AppendLine($"    .finalizer = {finalizerExpr},");
        sb.AppendLine($"    .interface_vtables = {ifaceVtablesExpr},");
        sb.AppendLine($"    .interface_vtable_count = {ifaceVtableCount},");
        // Custom attributes
        var typeAttrsExpr = (!skipReflection && type.CustomAttributes.Count > 0)
            ? $"{type.CppName}_custom_attrs" : "nullptr";
        var typeAttrCount = skipReflection ? 0 : type.CustomAttributes.Count;
        sb.AppendLine($"    .custom_attributes = {typeAttrsExpr},");
        sb.AppendLine($"    .custom_attribute_count = {typeAttrCount},");
        // Generic variance data (must match EmitGenericVarianceData filter)
        var typeInfoLookup = BuildTypeInfoExprLookup();
        var hasGenericArgs = type.IsGenericInstance && type.GenericArguments.Count > 0
                             && type.GenericParameterVariances.Count > 0
                             && type.GenericArguments.All(arg => typeInfoLookup.ContainsKey(arg));
        var genArgsExpr = hasGenericArgs ? $"{type.CppName}_generic_args" : "nullptr";
        var genVarExpr = hasGenericArgs ? $"{type.CppName}_generic_variances" : "nullptr";
        var genCount = hasGenericArgs ? type.GenericArguments.Count : 0;
        var genDefName = type.GenericDefinitionCppName != null
            ? $"\"{type.GenericDefinitionCppName}\"" : "nullptr";
        sb.AppendLine($"    .generic_arguments = {genArgsExpr},");
        sb.AppendLine($"    .generic_variances = {genVarExpr},");
        sb.AppendLine($"    .generic_argument_count = {genCount},");
        sb.AppendLine($"    .generic_definition_name = {genDefName},");
        sb.AppendLine("};");
    }

    /// <summary>
    /// Check if a BCL type should compile from IL instead of being stubbed.
    /// These are simple value types whose IL bodies have no deep BCL dependencies.
    /// </summary>
    private static bool IsCompileFromILType(IRType type)
    {
        return type.ILFullName == "System.Index"
            || type.ILFullName == "System.Range"
            || type.ILFullName.StartsWith("System.Nullable`");
    }

    /// <summary>
    /// Emit a stub method body for BCL methods.
    /// Returns a default value without compiling the IL body.
    /// </summary>
    private static void GenerateMethodStub(StringBuilder sb, IRMethod method)
    {
        sb.AppendLine($"// [BCL stub] {method.DeclaringType?.ILFullName}::{method.Name}");
        sb.Append($"{method.GetCppSignature()} {{ ");
        if (method.ReturnTypeCpp == "void")
            sb.AppendLine("}");
        else if (method.ReturnTypeCpp.EndsWith("*"))
            sb.AppendLine("return nullptr; }");
        else
        {
            var defaultVal = CppNameMapper.GetDefaultValue(method.ReturnTypeCpp);
            sb.AppendLine($"return {defaultVal}; }}");
        }
    }

    private void GenerateMethodImpl(StringBuilder sb, IRMethod method)
    {
        sb.AppendLine($"// {method.DeclaringType?.ILFullName}::{method.Name}");
        sb.AppendLine($"{method.GetCppSignature()} {{");

        // Declare local variables
        foreach (var local in method.Locals)
        {
            var defaultVal = CppNameMapper.GetDefaultValue(local.CppTypeName);
            sb.AppendLine($"    {local.CppTypeName} {local.CppName} = {defaultVal};");
        }

        // Collect temp variables that need auto declarations
        var declaredTemps = new HashSet<string>();
        string? lastLineDirective = null;

        // Check if method has any labels (branch targets)
        var allInstructions = method.BasicBlocks.SelectMany(b => b.Instructions).ToList();
        bool hasLabels = allInstructions.Any(i => i is IRLabel);

        // Pre-declare temp variables used across label scopes
        // (variables declared inside one { } label scope can't be used in another)
        if (hasLabels)
        {
            var crossScopeVars = FindCrossScopeVariables(allInstructions);
            foreach (var varName in crossScopeVars)
            {
                sb.AppendLine($"    cil2cpp::Object* {varName} = nullptr;");
                declaredTemps.Add(varName);
            }
        }
        bool inLabelScope = false;
        bool gotoScopeOpen = false;

        // Emit basic blocks
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                // When entering a label, close goto scope and label scope
                if (hasLabels && instr is IRLabel)
                {
                    if (gotoScopeOpen)
                    {
                        sb.AppendLine("    }");
                        gotoScopeOpen = false;
                    }
                    if (inLabelScope)
                        sb.AppendLine("    }");
                    // Emit the label at function scope
                    sb.AppendLine($"    {instr.ToCpp()}");
                    sb.AppendLine("    {");
                    inLabelScope = true;
                    continue;
                }

                // Exception handling instructions must be at function scope
                // (CIL2CPP_TRY/CATCH/FINALLY/END_TRY macros expand to { if / } else if / } })
                if (instr is IRTryBegin or IRCatchBegin or IRFinallyBegin or IRTryEnd)
                {
                    if (gotoScopeOpen)
                    {
                        sb.AppendLine("    }");
                        gotoScopeOpen = false;
                    }
                    if (inLabelScope)
                    {
                        sb.AppendLine("    }");
                        inLabelScope = false;
                    }
                }

                // Emit IL offset comment in Debug mode
                if (_config.EmitILOffsetComments && instr.DebugInfo != null && instr.DebugInfo.ILOffset >= 0
                    && instr is not IRComment && instr is not IRLabel)
                {
                    sb.AppendLine($"    /* IL_{instr.DebugInfo.ILOffset:X4} */");
                }

                // Emit #line directive in Debug mode (when source info is available)
                if (_config.EmitLineDirectives && instr.DebugInfo != null
                    && instr.DebugInfo.Line > 0
                    && !string.IsNullOrEmpty(instr.DebugInfo.FilePath)
                    && instr is not IRComment && instr is not IRLabel)
                {
                    // Normalize path separators for C++ (use forward slashes)
                    var filePath = instr.DebugInfo.FilePath.Replace("\\", "/");
                    var directive = $"#line {instr.DebugInfo.Line} \"{filePath}\"";

                    // Only emit if different from the last directive
                    if (directive != lastLineDirective)
                    {
                        sb.AppendLine($"    {directive}");
                        lastLineDirective = directive;
                    }
                }

                var code = instr.ToCpp();

                // For instructions that assign to temp vars, add 'auto' on first use
                code = AddAutoDeclarations(code, declaredTemps);

                var indent = (inLabelScope || gotoScopeOpen) ? "        " : "    ";
                sb.AppendLine($"{indent}{code}");

                // After a conditional/unconditional branch in the outer scope,
                // open a scope to prevent goto from crossing auto declarations (C++ C2362)
                if (hasLabels && !inLabelScope && !gotoScopeOpen
                    && (instr is IRConditionalBranch || instr is IRBranch))
                {
                    sb.AppendLine("    {");
                    gotoScopeOpen = true;
                }
            }
        }

        // Close last goto scope
        if (gotoScopeOpen)
            sb.AppendLine("    }");
        // Close last label scope
        if (inLabelScope)
            sb.AppendLine("    }");

        // In C++, there is no "#line default" like in C#.
        // We simply stop emitting #line directives; the compiler continues
        // using the last #line mapping until it encounters a new one.

        // If method doesn't end with return, add one
        var lastInstr = method.BasicBlocks
            .SelectMany(b => b.Instructions)
            .LastOrDefault();
        if (lastInstr is not IRReturn)
        {
            if (method.ReturnTypeCpp == "void")
                sb.AppendLine("    return;");
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    /// <summary>
    /// Find temp variables that are referenced across multiple label scopes.
    /// These must be pre-declared at function scope to avoid C++ scoping issues.
    /// </summary>
    private static HashSet<string> FindCrossScopeVariables(List<IRInstruction> instructions)
    {
        var result = new HashSet<string>();
        // Track which scope each variable is first assigned/used in
        // scope 0 = function scope, incrementing for each IRLabel
        int currentScope = 0;
        var varFirstScope = new Dictionary<string, int>();

        foreach (var instr in instructions)
        {
            if (instr is IRLabel)
            {
                currentScope++;
                continue;
            }

            var code = instr.ToCpp();
            // Find all __tN references in the code
            for (int i = 0; i < code.Length - 3; i++)
            {
                if (code[i] == '_' && code[i + 1] == '_' && code[i + 2] == 't'
                    && i + 3 < code.Length && char.IsDigit(code[i + 3]))
                {
                    // Check we're not inside __this, __type_info, etc.
                    if (i > 0 && char.IsLetterOrDigit(code[i - 1])) continue;

                    // Extract full variable name __tN
                    int end = i + 3;
                    while (end < code.Length && char.IsDigit(code[end])) end++;
                    // Make sure it's not followed by more identifier chars
                    if (end < code.Length && (char.IsLetter(code[end]) || code[end] == '_')) continue;

                    var varName = code[i..end];
                    if (varFirstScope.TryGetValue(varName, out var firstScope))
                    {
                        if (firstScope != currentScope)
                            result.Add(varName);
                    }
                    else
                    {
                        varFirstScope[varName] = currentScope;
                    }
                }
            }
        }
        return result;
    }

    /// <summary>
    /// Replace "__tN = expr" with "auto __tN = expr" on first use of temp vars.
    /// Only matches pure temp variables like __t0, __t1, etc.
    /// </summary>
    private string AddAutoDeclarations(string code, HashSet<string> declaredTemps)
    {
        // Match patterns like "__t0 = ..." but NOT "__this->..."
        if (code.StartsWith("__t") && !code.StartsWith("__this"))
        {
            var eqIdx = code.IndexOf(" = ");
            if (eqIdx > 0)
            {
                var varName = code[..eqIdx].Trim();
                // Must be a simple temp var name like __t0, __t1, etc.
                if (varName.StartsWith("__t") &&
                    varName.All(c => c == '_' || char.IsLetterOrDigit(c)) &&
                    !declaredTemps.Contains(varName))
                {
                    declaredTemps.Add(varName);
                    return $"auto {code}";
                }
            }
        }
        return code;
    }

    /// <summary>
    /// For runtime-provided reference types (System.String, System.Object), return the
    /// qualified name of the runtime's TypeInfo so we can alias to it instead of emitting a new one.
    /// Returns null for types that should get their own generated TypeInfo.
    /// </summary>
    private static string? GetRuntimeTypeInfoAlias(string ilFullName) => ilFullName switch
    {
        "System.String" => "cil2cpp::System::String_TypeInfo",
        "System.Object" => "cil2cpp::System::Object_TypeInfo",
        _ => null,
    };

    /// <summary>
    /// Generate a typed function pointer cast expression for a method, to resolve overload ambiguity.
    /// E.g., (void*)(void(*)(Foo*, int32_t))&Foo_Bar
    /// </summary>
    private string GetTypedMethodPointerCast(IRMethod method)
    {
        if (method.IsAbstract || method.BasicBlocks.Count == 0)
            return "nullptr";

        // Use actual declared parameter types for the cast so it matches the function
        // declaration — needed for overload resolution with MSVC.
        // Only sanitize IL function pointer types (contain parentheses) to void*.
        var retType = SanitizeFuncPtrType(method.ReturnTypeCpp ?? "void");
        var paramTypes = new List<string>();
        // Instance methods have implicit 'this' parameter
        if (!method.IsStatic && method.DeclaringType != null)
        {
            paramTypes.Add($"{method.DeclaringType.CppName}*");
        }
        foreach (var p in method.Parameters)
            paramTypes.Add(SanitizeFuncPtrType(p.CppTypeName));

        var funcPtrType = $"{retType}(*)({string.Join(", ", paramTypes)})";
        return $"(void*)({funcPtrType})&{method.CppName}";
    }

    /// <summary>
    /// Replace IL function pointer types (containing parentheses) with void*.
    /// These types can't be expressed in C++ function pointer casts.
    /// </summary>
    private static string SanitizeFuncPtrType(string cppType)
    {
        if (cppType.Contains("(") || cppType.Contains(")"))
            return "void*";
        return cppType;
    }

    /// <summary>
    /// Replace pointer-to-unknown-struct types with void* for safe function pointer casts.
    /// Types not defined in the compilation unit (BCL types like System_Type*) cause C++ errors.
    /// </summary>
    private string SafeCppType(string cppType)
    {
        if (cppType.EndsWith("*"))
        {
            var baseType = cppType.TrimEnd('*').Trim();
            if (baseType.StartsWith("cil2cpp::") || IsCppPrimitiveType(baseType))
                return cppType;
            // Check if the struct type is defined in the compilation unit
            if (_knownStructTypes == null) BuildKnownStructTypes();
            if (!_knownStructTypes!.Contains(baseType))
                return "void*";
        }
        return cppType;
    }

    private HashSet<string>? _knownStructTypes;
    private void BuildKnownStructTypes()
    {
        _knownStructTypes = new HashSet<string>();
        foreach (var type in _module.Types)
        {
            if (CppNameMapper.IsCompilerGeneratedType(type.ILFullName)) continue;
            if (type.IsInterface && type.Fields.Count == 0) continue;
            _knownStructTypes.Add(type.CppName);
        }
    }

    private void EmitVTableData(StringBuilder sb, List<IRType> userTypes)
    {
        // Build set of types whose methods are actually generated as C++ functions.
        // Methods from runtime-provided types (Object, ValueType, Enum, etc.) don't exist
        // as generated functions — VTable entries must use fallbacks for them.
        var generatedMethodTypes = new HashSet<string>();
        foreach (var t in userTypes)
        {
            if (!t.IsRuntimeProvided && !t.IsDelegate)
                generatedMethodTypes.Add(t.CppName);
        }

        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.IsDelegate || type.IsRuntimeProvided || type.VTable.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== VTable Data =====");
                any = true;
            }

            // Method pointer array
            var methods = string.Join(", ", type.VTable.Select(e =>
            {
                if (e.Method != null && !e.Method.IsAbstract)
                {
                    // If the method's declaring type is runtime-provided or not in generated types,
                    // the C++ function won't exist — use fallback
                    var declType = e.Method.DeclaringType;
                    if (declType != null && (declType.IsRuntimeProvided || !generatedMethodTypes.Contains(declType.CppName)))
                        return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
                    return GetTypedMethodPointerCast(e.Method);
                }
                return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
            }));
            sb.AppendLine($"static void* {type.CppName}_vtable_methods[] = {{ {methods} }};");
            sb.AppendLine($"static cil2cpp::VTable {type.CppName}_VTable = {{ &{type.CppName}_TypeInfo, {type.CppName}_vtable_methods, {type.VTable.Count} }};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitInterfaceData(StringBuilder sb, List<IRType> userTypes)
    {
        // Build set of types whose methods are generated (same as EmitVTableData)
        var generatedMethodTypes = new HashSet<string>();
        foreach (var t in userTypes)
        {
            if (!t.IsRuntimeProvided && !t.IsDelegate)
                generatedMethodTypes.Add(t.CppName);
        }

        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.IsRuntimeProvided || type.Interfaces.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== Interface Data =====");
                any = true;
            }

            // Interfaces pointer array
            var ifaces = string.Join(", ", type.Interfaces.Select(i => $"&{i.CppName}_TypeInfo"));
            sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_interfaces[] = {{ {ifaces} }};");
        }

        // Interface vtable method arrays and InterfaceVTable arrays
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.IsRuntimeProvided || type.InterfaceImpls.Count == 0) continue;

            foreach (var impl in type.InterfaceImpls)
            {
                var methods = string.Join(", ", impl.MethodImpls.Select(m =>
                {
                    if (m == null) return "nullptr";
                    // If the method's declaring type is runtime-provided or not generated, use nullptr
                    var declType = m.DeclaringType;
                    if (declType != null && (declType.IsRuntimeProvided || !generatedMethodTypes.Contains(declType.CppName)))
                        return "nullptr";
                    return GetTypedMethodPointerCast(m);
                }));
                sb.AppendLine($"static void* {type.CppName}_iface_{impl.Interface.CppName}_methods[] = {{ {methods} }};");
            }

            var entries = type.InterfaceImpls.Select(impl =>
                $"{{ &{impl.Interface.CppName}_TypeInfo, {type.CppName}_iface_{impl.Interface.CppName}_methods, {impl.MethodImpls.Count} }}");
            sb.AppendLine($"static cil2cpp::InterfaceVTable {type.CppName}_interface_vtables[] = {{");
            sb.AppendLine($"    {string.Join(",\n    ", entries)}");
            sb.AppendLine("};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitGenericVarianceData(StringBuilder sb, List<IRType> userTypes)
    {
        var typeInfoLookup = BuildTypeInfoExprLookup();
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.IsRuntimeProvided) continue;
            if (!type.IsGenericInstance || type.GenericArguments.Count == 0
                || type.GenericParameterVariances.Count == 0) continue;

            // Verify all generic arguments have TypeInfo available
            bool allArgsResolvable = type.GenericArguments.All(arg =>
                typeInfoLookup.ContainsKey(arg));
            if (!allArgsResolvable) continue;

            if (!any)
            {
                sb.AppendLine("// ===== Generic Variance Data =====");
                any = true;
            }

            // Emit TypeInfo pointer array for generic arguments
            var argRefs = type.GenericArguments.Select(arg => typeInfoLookup[arg]);
            sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_generic_args[] = {{ {string.Join(", ", argRefs)} }};");

            // Emit variance array
            var variances = type.GenericParameterVariances.Select(v => ((byte)v).ToString());
            sb.AppendLine($"static uint8_t {type.CppName}_generic_variances[] = {{ {string.Join(", ", variances)} }};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitFinalizerWrappers(StringBuilder sb, List<IRType> userTypes)
    {
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.Finalizer == null) continue;
            // Skip runtime-provided types — their Finalize method isn't generated
            if (type.IsRuntimeProvided) continue;
            // BCL types have stub finalizers — use System_Object_Finalize as fallback
            var isStubbed = type.SourceKind == AssemblyKind.BCL;
            if (!any)
            {
                sb.AppendLine("// ===== Finalizer Wrappers =====");
                any = true;
            }

            sb.AppendLine($"static void {type.CppName}_finalizer_wrapper(cil2cpp::Object* obj) {{");
            if (isStubbed)
                sb.AppendLine($"    System_Object_Finalize((System_Object*)obj);");
            else
                sb.AppendLine($"    {type.Finalizer.CppName}(({type.CppName}*)obj);");
            sb.AppendLine("}");
        }
        if (any) sb.AppendLine();
    }

    /// <summary>
    /// Build a lookup table mapping IL type full names to TypeInfo pointer expressions.
    /// Only includes types with TypeInfo emitted in generated code (non-runtime-provided user types + primitives).
    /// </summary>
    private Dictionary<string, string> BuildTypeInfoExprLookup()
    {
        var lookup = new Dictionary<string, string>();

        // User types that are not runtime-provided
        foreach (var type in _module.Types)
        {
            if (!type.IsRuntimeProvided && !CppNameMapper.IsCompilerGeneratedType(type.ILFullName))
            {
                lookup[type.ILFullName] = $"&{type.CppName}_TypeInfo";
            }
        }

        // Primitive types (array element types)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            lookup[entry.ILFullName] = $"&{entry.CppMangledName}_TypeInfo";
        }

        return lookup;
    }

    private void EmitReflectionMetadata(StringBuilder sb, List<IRType> userTypes)
    {
        var typeInfoLookup = BuildTypeInfoExprLookup();
        bool any = false;
        var emittedReflection = new HashSet<string>();

        foreach (var type in userTypes)
        {
            if (type.IsRuntimeProvided || type.IsEnum || type.IsDelegate) continue;
            // Skip runtime exception types — their C++ struct layout is defined by the runtime
            // and doesn't match the generated field layout (e.g., cil2cpp::ArgumentException has no f_paramName)
            if (CppNameMapper.IsRuntimeExceptionType(type.ILFullName)) continue;
            // Deduplicate — BCL proxies may appear multiple times
            if (!emittedReflection.Add(type.CppName)) continue;

            var allFields = type.Fields.Concat(type.StaticFields).ToList();
            var reflectableMethods = type.Methods
                .Where(m => !CppNameMapper.IsCompilerGeneratedType(m.Name))
                .ToList();

            if (allFields.Count == 0 && reflectableMethods.Count == 0) continue;

            if (!any)
            {
                sb.AppendLine("// ===== Reflection Metadata =====");
                any = true;
            }

            // Emit custom attribute arrays for type and fields
            // Type-level attributes
            if (type.CustomAttributes.Count > 0)
                EmitAttributeInfoArray(sb, $"{type.CppName}_custom_attrs", type.CustomAttributes);

            // Field-level attributes
            foreach (var field in allFields)
            {
                if (field.CustomAttributes.Count > 0)
                    EmitAttributeInfoArray(sb, $"{type.CppName}_{field.CppName}_attrs", field.CustomAttributes);
            }

            // Method-level attributes — use index suffix to disambiguate overloaded methods
            for (int mi = 0; mi < reflectableMethods.Count; mi++)
            {
                var method = reflectableMethods[mi];
                if (method.CustomAttributes.Count > 0)
                    EmitAttributeInfoArray(sb, $"{type.CppName}_m{mi}_attrs", method.CustomAttributes);
            }

            // Emit FieldInfo array
            if (allFields.Count > 0)
            {
                sb.AppendLine($"static cil2cpp::FieldInfo {type.CppName}_fields[] = {{");
                foreach (var field in allFields)
                {
                    var fieldTypeExpr = typeInfoLookup.GetValueOrDefault(field.FieldTypeName, "nullptr");
                    var offsetExpr = field.IsStatic ? "0" : $"offsetof({type.CppName}, {field.CppName})";
                    var fieldAttrsExpr = field.CustomAttributes.Count > 0
                        ? $"{type.CppName}_{field.CppName}_attrs" : "nullptr";
                    sb.AppendLine($"    {{ .name = \"{field.Name}\", " +
                        $".declaring_type = &{type.CppName}_TypeInfo, " +
                        $".field_type = {fieldTypeExpr}, " +
                        $".offset = {offsetExpr}, " +
                        $".flags = 0x{field.Attributes:X4}, " +
                        $".custom_attributes = {fieldAttrsExpr}, " +
                        $".custom_attribute_count = {field.CustomAttributes.Count} }},");
                }
                sb.AppendLine("};");
            }

            // Emit MethodInfo parameter type arrays and MethodInfo array
            if (reflectableMethods.Count > 0)
            {
                // First: parameter type arrays for methods that have parameters
                for (int mi = 0; mi < reflectableMethods.Count; mi++)
                {
                    var method = reflectableMethods[mi];
                    if (method.Parameters.Count == 0) continue;
                    var paramTypeExprs = method.Parameters
                        .Select(p => typeInfoLookup.GetValueOrDefault(p.ILTypeName, "nullptr"))
                        .ToList();
                    sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_m{mi}_param_types[] = {{ {string.Join(", ", paramTypeExprs)} }};");
                }

                // Second: MethodInfo array
                sb.AppendLine($"static cil2cpp::MethodInfo {type.CppName}_methods[] = {{");
                for (int mi = 0; mi < reflectableMethods.Count; mi++)
                {
                    var method = reflectableMethods[mi];
                    var returnTypeExpr = typeInfoLookup.GetValueOrDefault(
                        method.ReturnType?.ILFullName ?? "", "nullptr");
                    var paramTypesExpr = method.Parameters.Count > 0
                        ? $"{type.CppName}_m{mi}_param_types" : "nullptr";
                    // Check if the method was actually declared (not filtered by HasUnknownParameterTypes)
                    var hasValidSignature = !method.IsAbstract && !method.IsInternalCall
                        && method.BasicBlocks.Count > 0
                        && !method.Parameters.Any(p => p.CppTypeName.Contains("(") || p.CppTypeName.Contains(")"))
                        && !(method.ReturnTypeCpp?.Contains("(") == true);
                    var methodPtrExpr = hasValidSignature
                        ? GetTypedMethodPointerCast(method)
                        : "nullptr";
                    var methodAttrsExpr = method.CustomAttributes.Count > 0
                        ? $"{type.CppName}_m{mi}_attrs" : "nullptr";

                    sb.AppendLine($"    {{ .name = \"{method.Name}\", " +
                        $".declaring_type = &{type.CppName}_TypeInfo, " +
                        $".return_type = {returnTypeExpr}, " +
                        $".parameter_types = {paramTypesExpr}, " +
                        $".parameter_count = {method.Parameters.Count}, " +
                        $".method_pointer = {methodPtrExpr}, " +
                        $".flags = 0x{method.Attributes:X4}, " +
                        $".vtable_slot = {method.VTableSlot}, " +
                        $".custom_attributes = {methodAttrsExpr}, " +
                        $".custom_attribute_count = {method.CustomAttributes.Count} }},");
                }
                sb.AppendLine("};");
            }
        }
        if (any) sb.AppendLine();
    }

    /// <summary>
    /// Emit a single CustomAttributeInfo array and its argument arrays.
    /// </summary>
    private void EmitAttributeInfoArray(StringBuilder sb, string arrayName, List<IRCustomAttribute> attrs)
    {
        // First, emit argument arrays for attributes that have arguments
        for (int i = 0; i < attrs.Count; i++)
        {
            var attr = attrs[i];
            if (attr.ConstructorArgs.Count > 0)
            {
                sb.AppendLine($"static cil2cpp::CustomAttributeArg {arrayName}_{i}_args[] = {{");
                foreach (var arg in attr.ConstructorArgs)
                {
                    var valueInit = FormatAttributeArgValue(arg);
                    sb.AppendLine($"    {{ .type_name = \"{arg.TypeName}\", {valueInit} }},");
                }
                sb.AppendLine("};");
            }
        }

        // Then emit the CustomAttributeInfo array
        sb.AppendLine($"static cil2cpp::CustomAttributeInfo {arrayName}[] = {{");
        for (int i = 0; i < attrs.Count; i++)
        {
            var attr = attrs[i];
            var argsExpr = attr.ConstructorArgs.Count > 0
                ? $"{arrayName}_{i}_args" : "nullptr";
            sb.AppendLine($"    {{ .attribute_type_name = \"{attr.AttributeTypeName}\", " +
                $".args = {argsExpr}, " +
                $".arg_count = {attr.ConstructorArgs.Count} }},");
        }
        sb.AppendLine("};");
    }

    /// <summary>
    /// Format a custom attribute argument value for C++ designated initializer.
    /// </summary>
    private static string FormatAttributeArgValue(IRAttributeArg arg)
    {
        if (arg.Value == null)
            return ".string_val = nullptr";

        return arg.TypeName switch
        {
            "System.String" => $".string_val = \"{EscapeCppString(arg.Value.ToString() ?? "")}\"",
            "System.Single" => $".float_val = {FormatFloat(arg.Value)}",
            "System.Double" => $".float_val = {FormatDouble(arg.Value)}",
            "System.Boolean" => $".int_val = {((bool)arg.Value ? 1 : 0)}",
            "System.Char" => $".int_val = {(int)(char)arg.Value}",
            _ => $".int_val = {Convert.ToInt64(arg.Value)}",
        };
    }

    private static string EscapeCppString(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r");

    private static string FormatFloat(object val) =>
        ((float)val).ToString("G9", System.Globalization.CultureInfo.InvariantCulture);

    private static string FormatDouble(object val) =>
        ((double)val).ToString("G17", System.Globalization.CultureInfo.InvariantCulture);

    /// <summary>
    /// Emit extern "C" declarations and managed wrapper functions for P/Invoke methods.
    /// </summary>
    // C stdlib functions that are already declared via standard headers — don't re-declare
    private static readonly HashSet<string> CStdlibFunctions = new()
    {
        "strlen", "strcpy", "strncpy", "strcat", "strncat", "strcmp", "strncmp",
        "memcpy", "memmove", "memset", "memcmp", "malloc", "calloc", "realloc", "free",
        "printf", "sprintf", "snprintf", "fprintf", "puts", "putchar", "getchar",
        "abs", "atoi", "atof", "atol", "rand", "srand", "exit", "abort",
        "qsort", "bsearch", "time", "clock", "sin", "cos", "tan", "sqrt", "pow",
        "fopen", "fclose", "fread", "fwrite", "fseek", "ftell"
    };

    private void EmitPInvokeDeclarations(StringBuilder sb, List<IRType> userTypes)
    {
        var pinvokeMethods = userTypes
            .Where(t => !t.IsInterface && !t.IsDelegate && !t.IsRuntimeProvided
                        && t.SourceKind != AssemblyKind.BCL)
            .SelectMany(t => t.Methods)
            .Where(m => m.IsPInvoke)
            .Where(m => !m.Parameters.Any(p => p.CppTypeName.Contains("(") || p.CppTypeName.Contains(")")))
            .Where(m => !(m.ReturnTypeCpp.Contains("(") || m.ReturnTypeCpp.Contains(")")))
            .ToList();

        if (pinvokeMethods.Count == 0) return;

        // Filter out C stdlib functions that are already available via standard headers
        var needsExternDecl = pinvokeMethods
            .Where(m => !CStdlibFunctions.Contains(m.PInvokeEntryPoint ?? m.Name))
            .ToList();

        if (needsExternDecl.Count > 0)
        {
            sb.AppendLine("// ===== P/Invoke Declarations =====");
            sb.AppendLine("extern \"C\" {");

            foreach (var method in needsExternDecl)
            {
                var entryPoint = method.PInvokeEntryPoint ?? method.Name;
                var retType = GetPInvokeNativeType(method.ReturnTypeCpp);
                var paramTypes = method.Parameters.Select(p => GetPInvokeNativeType(p.CppTypeName)).ToList();
                var paramDecl = string.Join(", ", paramTypes.Select((t, i) => $"{t} p{i}"));
                sb.AppendLine($"    {retType} {entryPoint}({paramDecl});");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Generate managed wrappers that marshal String* ↔ const char*
        sb.AppendLine("// ===== P/Invoke Wrappers =====");
        foreach (var method in pinvokeMethods)
        {
            var entryPoint = method.PInvokeEntryPoint ?? method.Name;
            var retType = method.ReturnTypeCpp;
            var sig = method.GetCppSignature();

            sb.AppendLine($"// P/Invoke: {method.PInvokeModule}!{entryPoint}");
            sb.AppendLine($"{sig} {{");

            // Marshal arguments: String* → const char*
            var callArgs = new List<string>();
            for (int i = 0; i < method.Parameters.Count; i++)
            {
                var param = method.Parameters[i];
                if (IsStringType(param.CppTypeName))
                {
                    // Marshal String* to C string
                    sb.AppendLine($"    auto __p{i} = cil2cpp::string_to_utf8({param.CppName});");
                    callArgs.Add($"__p{i}");
                }
                else
                {
                    callArgs.Add(param.CppName);
                }
            }

            var argStr = string.Join(", ", callArgs);
            if (retType == "void")
            {
                sb.AppendLine($"    {entryPoint}({argStr});");
            }
            else if (IsStringType(retType))
            {
                // Marshal const char* return to String*
                sb.AppendLine($"    auto __ret = {entryPoint}({argStr});");
                sb.AppendLine($"    return cil2cpp::string_literal(__ret);");
            }
            else
            {
                sb.AppendLine($"    return {entryPoint}({argStr});");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Convert C++ managed type to native P/Invoke type.
    /// String* → const char*, other types pass through.
    /// </summary>
    private static string GetPInvokeNativeType(string cppType) => cppType switch
    {
        "cil2cpp::String*" => "const char*",
        "void" => "void",
        _ => cppType
    };

    private static bool IsStringType(string cppType) =>
        cppType is "cil2cpp::String*";
}
