using System.Text;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

public partial class CppCodeGenerator
{
    private GeneratedFile GenerateSource()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        if (_config.IsDebug)
        {
            sb.AppendLine("// DEBUG BUILD - contains #line directives and IL offset comments");
        }
        sb.AppendLine();
        sb.AppendLine($"#include \"{_module.Name}.h\"");
        sb.AppendLine();
        sb.AppendLine("#include <cstdio>");
        sb.AppendLine("#include <cmath>");
        sb.AppendLine("#include <cstring>");
        sb.AppendLine("#include <algorithm>");
        sb.AppendLine("#include <limits>");
        sb.AppendLine();

        // String literals
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// ===== String Literals =====");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                // Escape string for C++
                var escaped = EscapeString(value);
                sb.AppendLine($"static cil2cpp::String* {literal.Id} = nullptr;");
            }
            sb.AppendLine();

            sb.AppendLine("void __init_string_literals() {");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                var escaped = EscapeString(value);
                sb.AppendLine($"    {literal.Id} = cil2cpp::string_literal(\"{escaped}\");");
            }
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Array initializer data blobs
        if (_module.ArrayInitDataBlobs.Count > 0)
        {
            sb.AppendLine("// ===== Array Initializer Data =====");
            foreach (var blob in _module.ArrayInitDataBlobs)
            {
                var bytes = string.Join(", ", blob.Data.Select(b => $"0x{b:X2}"));
                sb.AppendLine($"static const unsigned char {blob.Id}[] = {{ {bytes} }};");
            }
            sb.AppendLine();
        }

        // Filter out compiler-generated types
        var userTypes = _module.Types
            .Where(t => !CppNameMapper.IsCompilerGeneratedType(t.ILFullName))
            .ToList();

        // Static field storage
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"{type.CppName}_Statics {type.CppName}_statics = {{}};");
            }
        }
        if (userTypes.Any(t => !t.IsEnum && !t.IsDelegate && t.StaticFields.Count > 0))
        {
            sb.AppendLine();
        }

        // Primitive type TypeInfo definitions (for array element types)
        if (_module.PrimitiveTypeInfos.Count > 0)
        {
            sb.AppendLine("// ===== Primitive Type Info (array element types) =====");
            foreach (var entry in _module.PrimitiveTypeInfos.Values)
            {
                sb.AppendLine($"cil2cpp::TypeInfo {entry.CppMangledName}_TypeInfo = {{");
                sb.AppendLine($"    .name = \"{entry.ILFullName.Split('.').Last()}\",");
                sb.AppendLine($"    .namespace_name = \"{entry.ILFullName[..entry.ILFullName.LastIndexOf('.')]}\",");
                sb.AppendLine($"    .full_name = \"{entry.ILFullName}\",");
                sb.AppendLine($"    .base_type = nullptr,");
                sb.AppendLine($"    .interfaces = nullptr,");
                sb.AppendLine($"    .interface_count = 0,");
                sb.AppendLine($"    .instance_size = sizeof({entry.CppTypeName}),");
                sb.AppendLine($"    .element_size = sizeof({entry.CppTypeName}),");
                sb.AppendLine($"    .flags = cil2cpp::TypeFlags::ValueType,");
                sb.AppendLine($"    .vtable = nullptr,");
                sb.AppendLine($"    .fields = nullptr,");
                sb.AppendLine($"    .field_count = 0,");
                sb.AppendLine($"    .methods = nullptr,");
                sb.AppendLine($"    .method_count = 0,");
                sb.AppendLine($"    .default_ctor = nullptr,");
                sb.AppendLine($"    .finalizer = nullptr,");
                sb.AppendLine($"    .interface_vtables = nullptr,");
                sb.AppendLine($"    .interface_vtable_count = 0,");
                sb.AppendLine($"}};");
            }
            sb.AppendLine();
        }

        // VTable data
        EmitVTableData(sb, userTypes);

        // Interface data
        EmitInterfaceData(sb, userTypes);

        // Finalizer wrappers
        EmitFinalizerWrappers(sb, userTypes);

        // Type info definitions (all types including interfaces)
        sb.AppendLine("// ===== Type Info =====");
        foreach (var type in userTypes)
        {
            GenerateTypeInfo(sb, type);
        }
        sb.AppendLine();

        // Static constructor guards
        foreach (var type in userTypes)
        {
            if (type.HasCctor)
            {
                var cctorMethod = type.Methods.FirstOrDefault(m => m.IsStaticConstructor);
                if (cctorMethod != null)
                {
                    sb.AppendLine($"static bool {type.CppName}_cctor_called = false;");
                    sb.AppendLine($"void {type.CppName}_ensure_cctor() {{");
                    sb.AppendLine($"    if (!{type.CppName}_cctor_called) {{");
                    sb.AppendLine($"        {type.CppName}_cctor_called = true;");
                    sb.AppendLine($"        {cctorMethod.CppName}();");
                    sb.AppendLine($"    }}");
                    sb.AppendLine($"}}");
                    sb.AppendLine();
                }
            }
        }

        // Method implementations
        sb.AppendLine("// ===== Method Implementations =====");
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.IsDelegate) continue;

            foreach (var method in type.Methods)
            {
                if (method.IsAbstract) continue;
                GenerateMethodImpl(sb, method);
            }
        }

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.cpp",
            Content = sb.ToString()
        };
    }

    private void GenerateTypeInfo(StringBuilder sb, IRType type)
    {
        var baseName = type.BaseType != null ? $"&{type.BaseType.CppName}_TypeInfo" : "nullptr";

        // Interfaces array
        var interfacesExpr = type.Interfaces.Count > 0 ? $"{type.CppName}_interfaces" : "nullptr";

        // VTable (delegates have no vtable)
        var vtableExpr = (!type.IsInterface && !type.IsDelegate && type.VTable.Count > 0) ? $"&{type.CppName}_VTable" : "nullptr";

        // Interface vtables
        var ifaceVtablesExpr = type.InterfaceImpls.Count > 0 ? $"{type.CppName}_interface_vtables" : "nullptr";

        // Finalizer
        var finalizerExpr = type.Finalizer != null ? $"{type.CppName}_finalizer_wrapper" : "nullptr";

        // Instance size (interfaces have no struct)
        var instanceSize = type.IsInterface ? "0" : $"sizeof({type.CppName})";

        // Flags
        var flagParts = new List<string>();
        if (type.IsValueType) flagParts.Add("cil2cpp::TypeFlags::ValueType");
        if (type.IsInterface) flagParts.Add("cil2cpp::TypeFlags::Interface");
        if (type.IsAbstract) flagParts.Add("cil2cpp::TypeFlags::Abstract");
        if (type.IsSealed) flagParts.Add("cil2cpp::TypeFlags::Sealed");
        if (type.IsEnum) flagParts.Add("cil2cpp::TypeFlags::Enum");
        var flagsStr = flagParts.Count > 0 ? string.Join(" | ", flagParts) : "cil2cpp::TypeFlags::None";

        sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{");
        sb.AppendLine($"    .name = \"{type.Name}\",");
        sb.AppendLine($"    .namespace_name = \"{type.Namespace}\",");
        sb.AppendLine($"    .full_name = \"{type.ILFullName}\",");
        sb.AppendLine($"    .base_type = {baseName},");
        sb.AppendLine($"    .interfaces = {interfacesExpr},");
        sb.AppendLine($"    .interface_count = {type.Interfaces.Count},");
        sb.AppendLine($"    .instance_size = {instanceSize},");
        sb.AppendLine($"    .element_size = 0,");
        sb.AppendLine($"    .flags = {flagsStr},");
        sb.AppendLine($"    .vtable = {vtableExpr},");
        sb.AppendLine($"    .fields = nullptr,");
        sb.AppendLine($"    .field_count = 0,");
        sb.AppendLine($"    .methods = nullptr,");
        sb.AppendLine($"    .method_count = 0,");
        sb.AppendLine($"    .default_ctor = nullptr,");
        sb.AppendLine($"    .finalizer = {finalizerExpr},");
        sb.AppendLine($"    .interface_vtables = {ifaceVtablesExpr},");
        sb.AppendLine($"    .interface_vtable_count = {type.InterfaceImpls.Count},");
        sb.AppendLine("};");
    }

    private void GenerateMethodImpl(StringBuilder sb, IRMethod method)
    {
        sb.AppendLine($"// {method.DeclaringType?.ILFullName}::{method.Name}");
        sb.AppendLine($"{method.GetCppSignature()} {{");

        // Declare local variables
        foreach (var local in method.Locals)
        {
            var defaultVal = CppNameMapper.GetDefaultValue(local.CppTypeName);
            sb.AppendLine($"    {local.CppTypeName} {local.CppName} = {defaultVal};");
        }

        // Collect temp variables that need auto declarations
        var declaredTemps = new HashSet<string>();
        string? lastLineDirective = null;

        // Check if method has any labels (branch targets)
        var allInstructions = method.BasicBlocks.SelectMany(b => b.Instructions).ToList();
        bool hasLabels = allInstructions.Any(i => i is IRLabel);
        bool inLabelScope = false;

        // Emit basic blocks
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                // When entering a label, close previous scope and open new one
                // This prevents goto from crossing auto declarations (C++ error C2362)
                if (hasLabels && instr is IRLabel)
                {
                    if (inLabelScope)
                        sb.AppendLine("    }");
                    // Emit the label at function scope
                    sb.AppendLine($"    {instr.ToCpp()}");
                    sb.AppendLine("    {");
                    inLabelScope = true;
                    continue;
                }

                // Emit IL offset comment in Debug mode
                if (_config.EmitILOffsetComments && instr.DebugInfo != null && instr.DebugInfo.ILOffset >= 0
                    && instr is not IRComment && instr is not IRLabel)
                {
                    sb.AppendLine($"    /* IL_{instr.DebugInfo.ILOffset:X4} */");
                }

                // Emit #line directive in Debug mode (when source info is available)
                if (_config.EmitLineDirectives && instr.DebugInfo != null
                    && instr.DebugInfo.Line > 0
                    && !string.IsNullOrEmpty(instr.DebugInfo.FilePath)
                    && instr is not IRComment && instr is not IRLabel)
                {
                    // Normalize path separators for C++ (use forward slashes)
                    var filePath = instr.DebugInfo.FilePath.Replace("\\", "/");
                    var directive = $"#line {instr.DebugInfo.Line} \"{filePath}\"";

                    // Only emit if different from the last directive
                    if (directive != lastLineDirective)
                    {
                        sb.AppendLine($"    {directive}");
                        lastLineDirective = directive;
                    }
                }

                var code = instr.ToCpp();

                // For instructions that assign to temp vars, add 'auto' on first use
                code = AddAutoDeclarations(code, declaredTemps);

                var indent = inLabelScope ? "        " : "    ";
                sb.AppendLine($"{indent}{code}");
            }
        }

        // Close last label scope
        if (inLabelScope)
            sb.AppendLine("    }");

        // In C++, there is no "#line default" like in C#.
        // We simply stop emitting #line directives; the compiler continues
        // using the last #line mapping until it encounters a new one.

        // If method doesn't end with return, add one
        var lastInstr = method.BasicBlocks
            .SelectMany(b => b.Instructions)
            .LastOrDefault();
        if (lastInstr is not IRReturn)
        {
            if (method.ReturnTypeCpp == "void")
                sb.AppendLine("    return;");
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    /// <summary>
    /// Replace "__tN = expr" with "auto __tN = expr" on first use of temp vars.
    /// Only matches pure temp variables like __t0, __t1, etc.
    /// </summary>
    private string AddAutoDeclarations(string code, HashSet<string> declaredTemps)
    {
        // Match patterns like "__t0 = ..." but NOT "__this->..."
        if (code.StartsWith("__t") && !code.StartsWith("__this"))
        {
            var eqIdx = code.IndexOf(" = ");
            if (eqIdx > 0)
            {
                var varName = code[..eqIdx].Trim();
                // Must be a simple temp var name like __t0, __t1, etc.
                if (varName.StartsWith("__t") &&
                    varName.All(c => c == '_' || char.IsLetterOrDigit(c)) &&
                    !declaredTemps.Contains(varName))
                {
                    declaredTemps.Add(varName);
                    return $"auto {code}";
                }
            }
        }
        return code;
    }

    private void EmitVTableData(StringBuilder sb, List<IRType> userTypes)
    {
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.IsDelegate || type.VTable.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== VTable Data =====");
                any = true;
            }

            // Method pointer array (null Method = System.Object base virtual, use BCL fallback)
            var methods = string.Join(", ", type.VTable.Select(e =>
            {
                if (e.Method != null && !e.Method.IsAbstract) return $"(void*){e.Method.CppName}";
                return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
            }));
            sb.AppendLine($"static void* {type.CppName}_vtable_methods[] = {{ {methods} }};");
            sb.AppendLine($"static cil2cpp::VTable {type.CppName}_VTable = {{ &{type.CppName}_TypeInfo, {type.CppName}_vtable_methods, {type.VTable.Count} }};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitInterfaceData(StringBuilder sb, List<IRType> userTypes)
    {
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.Interfaces.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== Interface Data =====");
                any = true;
            }

            // Interfaces pointer array
            var ifaces = string.Join(", ", type.Interfaces.Select(i => $"&{i.CppName}_TypeInfo"));
            sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_interfaces[] = {{ {ifaces} }};");
        }

        // Interface vtable method arrays and InterfaceVTable arrays
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.InterfaceImpls.Count == 0) continue;

            foreach (var impl in type.InterfaceImpls)
            {
                var methods = string.Join(", ", impl.MethodImpls.Select(m => m != null ? $"(void*){m.CppName}" : "nullptr"));
                sb.AppendLine($"static void* {type.CppName}_iface_{impl.Interface.CppName}_methods[] = {{ {methods} }};");
            }

            var entries = type.InterfaceImpls.Select(impl =>
                $"{{ &{impl.Interface.CppName}_TypeInfo, {type.CppName}_iface_{impl.Interface.CppName}_methods, {impl.MethodImpls.Count} }}");
            sb.AppendLine($"static cil2cpp::InterfaceVTable {type.CppName}_interface_vtables[] = {{");
            sb.AppendLine($"    {string.Join(",\n    ", entries)}");
            sb.AppendLine("};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitFinalizerWrappers(StringBuilder sb, List<IRType> userTypes)
    {
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.Finalizer == null) continue;
            if (!any)
            {
                sb.AppendLine("// ===== Finalizer Wrappers =====");
                any = true;
            }

            sb.AppendLine($"static void {type.CppName}_finalizer_wrapper(cil2cpp::Object* obj) {{");
            sb.AppendLine($"    {type.Finalizer.CppName}(({type.CppName}*)obj);");
            sb.AppendLine("}");
        }
        if (any) sb.AppendLine();
    }
}
