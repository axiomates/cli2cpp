using System.Text;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

public partial class CppCodeGenerator
{
    private GeneratedFile GenerateHeader()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        sb.AppendLine();
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        sb.AppendLine("#include <cil2cpp/cil2cpp.h>");
        sb.AppendLine();

        // Filter out compiler-generated types
        var userTypes = _module.Types
            .Where(t => !CppNameMapper.IsCompilerGeneratedType(t.ILFullName))
            .ToList();

        // Forward declarations (skip interfaces, enums, and delegates â€” no struct defs)
        sb.AppendLine("// ===== Forward Declarations =====");
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.IsEnum || type.IsDelegate) continue;
            sb.AppendLine($"struct {type.CppName};");
        }
        sb.AppendLine();

        // Type info declarations (includes interfaces for dispatch)
        sb.AppendLine("// ===== Type Info Declarations =====");
        foreach (var type in userTypes)
        {
            sb.AppendLine($"extern cil2cpp::TypeInfo {type.CppName}_TypeInfo;");
        }
        // Primitive type TypeInfo declarations (for array element types)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            sb.AppendLine($"extern cil2cpp::TypeInfo {entry.CppMangledName}_TypeInfo;");
        }
        sb.AppendLine();

        // Struct definitions
        sb.AppendLine("// ===== Type Definitions =====");
        foreach (var type in userTypes)
        {
            if (type.IsInterface) continue;
            if (type.IsEnum)
            {
                GenerateEnumDefinition(sb, type);
                continue;
            }
            if (type.IsDelegate)
            {
                // Delegates are aliases for cil2cpp::Delegate
                sb.AppendLine($"using {type.CppName} = cil2cpp::Delegate;");
                sb.AppendLine();
                continue;
            }
            GenerateStructDefinition(sb, type);
        }

        // Static field storage declarations
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"// Static fields for {type.ILFullName}");
                sb.AppendLine($"struct {type.CppName}_Statics {{");
                foreach (var field in type.StaticFields)
                {
                    var cppType = CppNameMapper.GetCppTypeForDecl(field.FieldTypeName);
                    sb.AppendLine($"    {cppType} {field.CppName};");
                }
                sb.AppendLine("};");
                sb.AppendLine($"extern {type.CppName}_Statics {type.CppName}_statics;");
                sb.AppendLine();
            }
        }

        // Method declarations
        sb.AppendLine("// ===== Method Declarations =====");
        foreach (var type in userTypes)
        {
            if (type.IsInterface || type.IsDelegate) continue;

            foreach (var method in type.Methods)
            {
                if (method.IsAbstract) continue;
                sb.AppendLine($"{method.GetCppSignature()};");
            }
            sb.AppendLine();
        }

        // Static constructor guard declarations
        foreach (var type in userTypes)
        {
            if (type.HasCctor)
            {
                sb.AppendLine($"void {type.CppName}_ensure_cctor();");
            }
        }
        if (userTypes.Any(t => t.HasCctor))
            sb.AppendLine();

        // String literal initializer declaration
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// String literal initializer");
            sb.AppendLine("void __init_string_literals();");
            sb.AppendLine();
        }

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.h",
            Content = sb.ToString()
        };
    }

    private void GenerateStructDefinition(StringBuilder sb, IRType type)
    {
        sb.AppendLine($"// {type.ILFullName}");

        if (type.IsValueType)
        {
            sb.AppendLine($"struct {type.CppName} {{");
        }
        else
        {
            sb.AppendLine($"struct {type.CppName} {{");
            sb.AppendLine($"    cil2cpp::TypeInfo* __type_info;");
            sb.AppendLine($"    cil2cpp::UInt32 __sync_block;");

            // Base type fields (walk full inheritance chain)
            var inheritedFields = CollectInheritedFields(type);
            if (inheritedFields.Count > 0)
            {
                sb.AppendLine($"    // Inherited fields");
                foreach (var (field, fromType) in inheritedFields)
                {
                    var cppType = CppNameMapper.GetCppTypeForDecl(field.FieldTypeName);
                    sb.AppendLine($"    {cppType} {field.CppName}; // from {fromType.ILFullName}");
                }
            }
        }

        // Own fields
        foreach (var field in type.Fields)
        {
            var cppType = CppNameMapper.GetCppTypeForDecl(field.FieldTypeName);
            sb.AppendLine($"    {cppType} {field.CppName};");
        }

        sb.AppendLine("};");
        sb.AppendLine();
    }

    private static List<(IRField Field, IRType FromType)> CollectInheritedFields(IRType type)
    {
        var result = new List<(IRField, IRType)>();
        var ancestors = new List<IRType>();
        var current = type.BaseType;
        while (current != null && current.ILFullName != "System.Object")
        {
            ancestors.Add(current);
            current = current.BaseType;
        }
        ancestors.Reverse(); // furthest ancestor first
        foreach (var ancestor in ancestors)
        {
            foreach (var field in ancestor.Fields)
                result.Add((field, ancestor));
        }
        return result;
    }

    private void GenerateEnumDefinition(StringBuilder sb, IRType type)
    {
        var underlyingCppType = CppNameMapper.GetCppTypeForDecl(type.EnumUnderlyingType ?? "System.Int32");
        sb.AppendLine($"// {type.ILFullName} (enum)");
        sb.AppendLine($"using {type.CppName} = {underlyingCppType};");

        // Emit named constants
        foreach (var field in type.StaticFields)
        {
            if (field.ConstantValue != null)
            {
                sb.AppendLine($"constexpr {underlyingCppType} {type.CppName}_{field.CppName} = {field.ConstantValue};");
            }
        }
        sb.AppendLine();
    }
}
