using System.Text;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

/// <summary>
/// Generates C++ source code from IR module.
/// </summary>
public class CppCodeGenerator
{
    private readonly IRModule _module;
    private readonly BuildConfiguration _config;

    public CppCodeGenerator(IRModule module, BuildConfiguration? config = null)
    {
        _module = module;
        _config = config ?? BuildConfiguration.Release;
    }

    /// <summary>
    /// Generate all C++ files for the module.
    /// </summary>
    public GeneratedOutput Generate()
    {
        var output = new GeneratedOutput();

        // Generate header file with all type declarations
        output.HeaderFile = GenerateHeader();

        // Generate source file with all implementations
        output.SourceFile = GenerateSource();

        // Generate main entry point only for executable projects (with entry point)
        if (_module.EntryPoint != null)
        {
            output.MainFile = GenerateMain();
        }

        // Generate CMakeLists.txt
        output.CMakeFile = GenerateCMakeLists();

        return output;
    }

    private GeneratedFile GenerateHeader()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        sb.AppendLine();
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        sb.AppendLine("#include <cil2cpp/cil2cpp.h>");
        sb.AppendLine();

        // Forward declarations
        sb.AppendLine("// ===== Forward Declarations =====");
        foreach (var type in _module.Types)
        {
            if (type.IsInterface) continue;
            sb.AppendLine($"struct {type.CppName};");
        }
        sb.AppendLine();

        // Type info declarations
        sb.AppendLine("// ===== Type Info Declarations =====");
        foreach (var type in _module.Types)
        {
            if (type.IsInterface) continue;
            sb.AppendLine($"extern cil2cpp::TypeInfo {type.CppName}_TypeInfo;");
        }
        sb.AppendLine();

        // Struct definitions
        sb.AppendLine("// ===== Type Definitions =====");
        foreach (var type in _module.Types)
        {
            if (type.IsInterface) continue;
            GenerateStructDefinition(sb, type);
        }

        // Static field storage declarations
        foreach (var type in _module.Types)
        {
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"// Static fields for {type.ILFullName}");
                sb.AppendLine($"struct {type.CppName}_Statics {{");
                foreach (var field in type.StaticFields)
                {
                    var cppType = CppNameMapper.GetCppTypeForDecl(field.FieldTypeName);
                    sb.AppendLine($"    {cppType} {field.CppName};");
                }
                sb.AppendLine("};");
                sb.AppendLine($"extern {type.CppName}_Statics {type.CppName}_statics;");
                sb.AppendLine();
            }
        }

        // Method declarations
        sb.AppendLine("// ===== Method Declarations =====");
        foreach (var type in _module.Types)
        {
            if (type.IsInterface) continue;

            foreach (var method in type.Methods)
            {
                if (method.IsAbstract) continue;
                sb.AppendLine($"{method.GetCppSignature()};");
            }
            sb.AppendLine();
        }

        // String literal initializer declaration
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// String literal initializer");
            sb.AppendLine("void __init_string_literals();");
            sb.AppendLine();
        }

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.h",
            Content = sb.ToString()
        };
    }

    private void GenerateStructDefinition(StringBuilder sb, IRType type)
    {
        sb.AppendLine($"// {type.ILFullName}");

        if (type.IsValueType)
        {
            sb.AppendLine($"struct {type.CppName} {{");
        }
        else
        {
            sb.AppendLine($"struct {type.CppName} {{");
            sb.AppendLine($"    cil2cpp::TypeInfo* __type_info;");
            sb.AppendLine($"    cil2cpp::UInt32 __sync_block;");

            // Base type fields (if not Object)
            if (type.BaseType != null && type.BaseType.ILFullName != "System.Object")
            {
                sb.AppendLine($"    // Base type fields ({type.BaseType.ILFullName})");
                foreach (var field in type.BaseType.Fields)
                {
                    var cppType = CppNameMapper.GetCppTypeForDecl(field.FieldTypeName);
                    sb.AppendLine($"    {cppType} {field.CppName}; // inherited");
                }
            }
        }

        // Own fields
        foreach (var field in type.Fields)
        {
            var cppType = CppNameMapper.GetCppTypeForDecl(field.FieldTypeName);
            sb.AppendLine($"    {cppType} {field.CppName};");
        }

        sb.AppendLine("};");
        sb.AppendLine();
    }

    private GeneratedFile GenerateSource()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        if (_config.IsDebug)
        {
            sb.AppendLine("// DEBUG BUILD - contains #line directives and IL offset comments");
        }
        sb.AppendLine();
        sb.AppendLine($"#include \"{_module.Name}.h\"");
        sb.AppendLine();
        sb.AppendLine("#include <cstdio>");
        sb.AppendLine();

        // String literals
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// ===== String Literals =====");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                // Escape string for C++
                var escaped = EscapeString(value);
                sb.AppendLine($"static cil2cpp::String* {literal.Id} = nullptr;");
            }
            sb.AppendLine();

            sb.AppendLine("void __init_string_literals() {");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                var escaped = EscapeString(value);
                sb.AppendLine($"    {literal.Id} = cil2cpp::string_literal(\"{escaped}\");");
            }
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Static field storage
        foreach (var type in _module.Types)
        {
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"{type.CppName}_Statics {type.CppName}_statics = {{}};");
            }
        }
        if (_module.Types.Any(t => t.StaticFields.Count > 0))
        {
            sb.AppendLine();
        }

        // Type info definitions
        sb.AppendLine("// ===== Type Info =====");
        foreach (var type in _module.Types)
        {
            if (type.IsInterface) continue;
            GenerateTypeInfo(sb, type);
        }
        sb.AppendLine();

        // Method implementations
        sb.AppendLine("// ===== Method Implementations =====");
        foreach (var type in _module.Types)
        {
            if (type.IsInterface) continue;

            foreach (var method in type.Methods)
            {
                if (method.IsAbstract) continue;
                GenerateMethodImpl(sb, method);
            }
        }

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.cpp",
            Content = sb.ToString()
        };
    }

    private void GenerateTypeInfo(StringBuilder sb, IRType type)
    {
        var baseName = type.BaseType != null ? $"&{type.BaseType.CppName}_TypeInfo" : "nullptr";

        sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{");
        sb.AppendLine($"    .name = \"{type.Name}\",");
        sb.AppendLine($"    .namespace_name = \"{type.Namespace}\",");
        sb.AppendLine($"    .full_name = \"{type.ILFullName}\",");
        sb.AppendLine($"    .base_type = {baseName},");
        sb.AppendLine($"    .interfaces = nullptr,");
        sb.AppendLine($"    .interface_count = 0,");
        sb.AppendLine($"    .instance_size = sizeof({type.CppName}),");
        sb.AppendLine($"    .element_size = 0,");

        var flags = "cil2cpp::TypeFlags::None";
        if (type.IsValueType) flags = "cil2cpp::TypeFlags::ValueType";
        if (type.IsInterface) flags = "cil2cpp::TypeFlags::Interface";
        if (type.IsAbstract) flags += " | cil2cpp::TypeFlags::Abstract";
        if (type.IsSealed) flags += " | cil2cpp::TypeFlags::Sealed";

        sb.AppendLine($"    .flags = {flags},");
        sb.AppendLine($"    .vtable = nullptr,");
        sb.AppendLine($"    .fields = nullptr,");
        sb.AppendLine($"    .field_count = 0,");
        sb.AppendLine($"    .methods = nullptr,");
        sb.AppendLine($"    .method_count = 0,");
        sb.AppendLine($"    .default_ctor = nullptr,");
        sb.AppendLine($"    .finalizer = nullptr,");
        sb.AppendLine("};");
    }

    private void GenerateMethodImpl(StringBuilder sb, IRMethod method)
    {
        sb.AppendLine($"// {method.DeclaringType?.ILFullName}::{method.Name}");
        sb.AppendLine($"{method.GetCppSignature()} {{");

        // Declare local variables
        foreach (var local in method.Locals)
        {
            var defaultVal = CppNameMapper.GetDefaultValue(local.CppTypeName);
            sb.AppendLine($"    {local.CppTypeName} {local.CppName} = {defaultVal};");
        }

        // Collect temp variables that need auto declarations
        var declaredTemps = new HashSet<string>();
        string? lastLineDirective = null;

        // Emit basic blocks
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                // Emit IL offset comment in Debug mode
                if (_config.EmitILOffsetComments && instr.DebugInfo != null && instr.DebugInfo.ILOffset >= 0
                    && instr is not IRComment && instr is not IRLabel)
                {
                    sb.AppendLine($"    /* IL_{instr.DebugInfo.ILOffset:X4} */");
                }

                // Emit #line directive in Debug mode (when source info is available)
                if (_config.EmitLineDirectives && instr.DebugInfo != null
                    && instr.DebugInfo.Line > 0
                    && !string.IsNullOrEmpty(instr.DebugInfo.FilePath)
                    && instr is not IRComment && instr is not IRLabel)
                {
                    // Normalize path separators for C++ (use forward slashes)
                    var filePath = instr.DebugInfo.FilePath.Replace("\\", "/");
                    var directive = $"#line {instr.DebugInfo.Line} \"{filePath}\"";

                    // Only emit if different from the last directive
                    if (directive != lastLineDirective)
                    {
                        sb.AppendLine($"    {directive}");
                        lastLineDirective = directive;
                    }
                }

                var code = instr.ToCpp();

                // For instructions that assign to temp vars, add 'auto' on first use
                code = AddAutoDeclarations(code, declaredTemps);

                sb.AppendLine($"    {code}");
            }
        }

        // In C++, there is no "#line default" like in C#.
        // We simply stop emitting #line directives; the compiler continues
        // using the last #line mapping until it encounters a new one.

        // If method doesn't end with return, add one
        var lastInstr = method.BasicBlocks
            .SelectMany(b => b.Instructions)
            .LastOrDefault();
        if (lastInstr is not IRReturn)
        {
            if (method.ReturnTypeCpp == "void")
                sb.AppendLine("    return;");
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    /// <summary>
    /// Replace "__tN = expr" with "auto __tN = expr" on first use of temp vars.
    /// Only matches pure temp variables like __t0, __t1, etc.
    /// </summary>
    private string AddAutoDeclarations(string code, HashSet<string> declaredTemps)
    {
        // Match patterns like "__t0 = ..." but NOT "__this->..."
        if (code.StartsWith("__t") && !code.StartsWith("__this"))
        {
            var eqIdx = code.IndexOf(" = ");
            if (eqIdx > 0)
            {
                var varName = code[..eqIdx].Trim();
                // Must be a simple temp var name like __t0, __t1, etc.
                if (varName.StartsWith("__t") && varName.Length <= 8 &&
                    varName.All(c => c == '_' || char.IsLetterOrDigit(c)) &&
                    !declaredTemps.Contains(varName))
                {
                    declaredTemps.Add(varName);
                    return $"auto {code}";
                }
            }
        }
        return code;
    }

    private GeneratedFile GenerateMain()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Entry point for {_module.Name}");
        sb.AppendLine();
        sb.AppendLine($"#include \"{_module.Name}.h\"");
        sb.AppendLine();
        sb.AppendLine("int main(int argc, char* argv[]) {");
        sb.AppendLine("    cil2cpp::runtime_init();");
        sb.AppendLine();

        // Initialize string literals
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("    __init_string_literals();");
            sb.AppendLine();
        }

        // Call entry point
        if (_module.EntryPoint != null)
        {
            sb.AppendLine($"    // Call {_module.EntryPoint.DeclaringType?.ILFullName}::{_module.EntryPoint.Name}");
            sb.AppendLine($"    {_module.EntryPoint.CppName}();");
        }
        else
        {
            sb.AppendLine("    // WARNING: No entry point found");
        }

        sb.AppendLine();
        sb.AppendLine("    cil2cpp::runtime_shutdown();");
        sb.AppendLine("    return 0;");
        sb.AppendLine("}");

        return new GeneratedFile
        {
            FileName = "main.cpp",
            Content = sb.ToString()
        };
    }

    private GeneratedFile GenerateCMakeLists()
    {
        var sb = new StringBuilder();
        var projectName = _module.Name;
        bool isExe = _module.EntryPoint != null;
        var linkVisibility = isExe ? "PRIVATE" : "PUBLIC";

        sb.AppendLine("# Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine("cmake_minimum_required(VERSION 3.20)");
        sb.AppendLine($"project({projectName} CXX)");
        sb.AppendLine();
        sb.AppendLine("set(CMAKE_CXX_STANDARD 20)");
        sb.AppendLine("set(CMAKE_CXX_STANDARD_REQUIRED ON)");
        sb.AppendLine();

        // Default build type
        sb.AppendLine("if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)");
        sb.AppendLine($"    set(CMAKE_BUILD_TYPE \"{_config.ConfigurationName}\" CACHE STRING \"Build type\" FORCE)");
        sb.AppendLine("    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\")");
        sb.AppendLine("endif()");
        sb.AppendLine();

        // Target: executable or static library
        if (isExe)
        {
            sb.AppendLine($"add_executable({projectName}");
            sb.AppendLine("    main.cpp");
            sb.AppendLine($"    {projectName}.cpp");
            sb.AppendLine(")");
        }
        else
        {
            sb.AppendLine($"add_library({projectName} STATIC");
            sb.AppendLine($"    {projectName}.cpp");
            sb.AppendLine(")");
            sb.AppendLine();
            sb.AppendLine($"target_include_directories({projectName} PUBLIC");
            sb.AppendLine("    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>");
            sb.AppendLine(")");
        }
        sb.AppendLine();

        // CIL2CPP Runtime via find_package
        sb.AppendLine("find_package(cil2cpp REQUIRED)");
        sb.AppendLine($"target_link_libraries({projectName} {linkVisibility} cil2cpp::runtime)");
        sb.AppendLine();

        // Debug/Release settings for generated code
        sb.AppendLine($"target_compile_definitions({projectName} {linkVisibility}");
        sb.AppendLine("    $<$<CONFIG:Debug>:CIL2CPP_DEBUG>)");
        sb.AppendLine();

        sb.AppendLine("if(MSVC)");
        sb.AppendLine($"    target_compile_options({projectName} PRIVATE");
        sb.AppendLine("        $<$<CONFIG:Debug>:/Zi /Od /RTC1>");
        sb.AppendLine("        $<$<CONFIG:Release>:/O2 /DNDEBUG>");
        sb.AppendLine("    )");
        if (isExe)
        {
            sb.AppendLine($"    target_link_options({projectName} PRIVATE");
            sb.AppendLine("        $<$<CONFIG:Debug>:/DEBUG>)");
        }
        sb.AppendLine("else()");
        sb.AppendLine($"    target_compile_options({projectName} PRIVATE");
        sb.AppendLine("        $<$<CONFIG:Debug>:-g -O0>");
        sb.AppendLine("        $<$<CONFIG:Release>:-O2 -DNDEBUG>");
        sb.AppendLine("    )");
        sb.AppendLine("endif()");

        return new GeneratedFile
        {
            FileName = "CMakeLists.txt",
            Content = sb.ToString()
        };
    }

    private static string EscapeString(string s)
    {
        return s
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t")
            .Replace("\0", "\\0");
    }
}

public class GeneratedOutput
{
    public GeneratedFile HeaderFile { get; set; } = new();
    public GeneratedFile SourceFile { get; set; } = new();
    public GeneratedFile? MainFile { get; set; }
    public GeneratedFile? CMakeFile { get; set; }

    /// <summary>
    /// Write all generated files to a directory.
    /// </summary>
    public void WriteToDirectory(string outputDir)
    {
        Directory.CreateDirectory(outputDir);
        File.WriteAllText(Path.Combine(outputDir, HeaderFile.FileName), HeaderFile.Content);
        File.WriteAllText(Path.Combine(outputDir, SourceFile.FileName), SourceFile.Content);
        if (MainFile != null)
        {
            File.WriteAllText(Path.Combine(outputDir, MainFile.FileName), MainFile.Content);
        }
        if (CMakeFile != null)
        {
            File.WriteAllText(Path.Combine(outputDir, CMakeFile.FileName), CMakeFile.Content);
        }
    }
}

public class GeneratedFile
{
    public string FileName { get; set; } = "";
    public string Content { get; set; } = "";
}
